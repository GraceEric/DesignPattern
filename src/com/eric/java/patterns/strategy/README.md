策略者模式：模拟鸭子游戏

1、需求分析:鸭子的外形不同，当然还有一些共性，实现如first版本

2、新需求：鸭子飞

1）方案一：在超类里面加fly功能，子类都继承了；  （鸭子不是都会飞，所以此设计不合理）
2）方案二: 在超类里面加抽象fly（），让子类函数；（所有的鸭子都要实现，代码的复用性降低了）

3、新需求：石头鸭子  不会叫 不会游泳 不会飞

原来的设计 ，所有的都要覆盖，代码要重复，增加工作量，复杂度O（N^2）

综上：使用策略者模式解决新需求

1）分析项目变化与不变化的部分，提取变化的部分，抽象成接口+实现
    如鸭子的变化部分：叫声（gege ，gaga，gugu） 飞行。。。

    public interface QuackBehavior {
        void quack();
    }
    ß
    public interface FlyBehavior {
        void fly();
    }

    好处: 新增行为简单，行为类更好的复用，组合更刚方便


策略模式：
1、分别封装行为接口，实现算法族
2、抽象超类中放接口对象，在子类里具体设定行为对象

原则： 分离变化的部分，封装接口，基于接口编程各种功能。 让行为算法的变化独立于算法的使用者。